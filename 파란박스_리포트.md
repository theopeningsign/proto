# 파란박스(간판편집) 현황 리포트

## 📋 현재 상태

### 1. 기능 현황

#### ✅ 구현된 기능
- **박스 이동**: 파란색 박스를 드래그하여 위치 변경 가능
- **박스 크기 조절**: 오른쪽 아래 모서리 핸들을 드래그하여 크기 조절
- **회전**: 상단 핸들을 드래그하여 회전
- **fontSize 연동**: 박스 크기 조절 시 fontSize 자동 조정
- **초기화**: 간판 영역(polygon_points) 기반으로 박스 초기 위치/크기 설정

#### ❌ 미구현 기능
- **텍스트 위치 연동**: 박스 이동 시 `textPositionX/Y` 자동 계산 및 업데이트 없음
- **selectedArea 전달**: `SignboardTransform`에 `selectedArea` props가 전달되지 않음
- **textSizeInfo 전달**: `SignboardTransform`에 `textSizeInfo` props가 전달되지 않음

---

## 🔍 코드 분석

### SignboardTransform.js (현재 상태)

#### Props (현재)
```javascript
{
  signboards,           // ✅ 있음
  originalSignboards,   // ✅ 있음
  imageSize,            // ✅ 있음
  onTransformChange,    // ✅ 있음
  onApply,              // ✅ 있음
  onSelectSignboard     // ✅ 있음
}
```

#### Props (필요하지만 없음)
```javascript
{
  selectedArea,         // ❌ 없음 - 간판 영역 정보 필요
  textSizeInfo          // ❌ 없음 - 텍스트 실제 크기 정보 필요
}
```

#### handleMouseMove - move 모드 (현재)
```javascript
if (dragMode === 'move') {
  updateTransform(selectedId, {
    x: transform.x + dx,
    y: transform.y + dy,
    // ❌ textPositionX/Y 계산 없음
  });
}
```

**문제점**: 박스를 이동해도 `textPositionX/Y`가 업데이트되지 않음

---

### ResultViewer.js (현재 상태)

#### SignboardTransform 호출 부분
```javascript
<SignboardTransform
  signboards={...}
  originalSignboards={originalSignboards}
  imageSize={imageSize}
  onTransformChange={setPendingTransforms}
  onApply={handleApplyTransforms}
  // ❌ selectedArea={selectedArea} 없음
  // ❌ textSizeInfo={textSizeInfo} 없음
/>
```

**문제점**: 필요한 props가 전달되지 않음

---

### App.js (현재 상태)

#### onRegenerateWithTransforms (현재)
```javascript
if (transform.fontSize !== undefined) {
  updatedFormData.fontSize = transform.fontSize;
}
if (transform.rotation !== undefined) {
  updatedFormData.rotation = transform.rotation;
}
// ❌ textPositionX/Y 처리 없음
```

**문제점**: `textPositionX/Y`를 transform에서 받아서 업데이트하는 로직이 없음

---

## 🚨 주요 문제점

### 1. 기능 분리 문제
- **파란박스(간판편집)**: 박스 이동/크기/회전만 처리
- **보라박스(상호 위치)**: 텍스트 위치만 처리
- **결과**: 두 기능이 완전히 분리되어 있어 사용자가 혼란스러울 수 있음

### 2. 데이터 동기화 문제
- 파란박스를 이동해도 `textPositionX/Y`가 업데이트되지 않음
- "적용하기" 후 재생성 시 텍스트 위치가 변경되지 않음
- 사용자가 파란박스로 위치를 조정해도 실제 텍스트 위치는 변하지 않음

### 3. Props 전달 누락
- `selectedArea`: 간판 영역 정보가 필요하지만 전달되지 않음
- `textSizeInfo`: 텍스트 실제 크기가 필요하지만 전달되지 않음

### 4. 좌표 변환 로직 부재
- 박스 중심 좌표 → 간판 영역 내 상대 좌표 변환 로직 없음
- 간판 영역 내 상대 좌표 → textPositionX/Y 변환 로직 없음

---

## 💡 개선 방안

### 방안 1: 통합 구현 (권장) ⭐

**목표**: 파란박스 이동 시 텍스트 위치 자동 업데이트

#### 수정 사항

**1. SignboardTransform.js**
```javascript
// Props 추가
const SignboardTransform = ({ 
  signboards,
  originalSignboards,
  imageSize,
  onTransformChange,
  onApply,
  onSelectSignboard,
  selectedArea,        // ✅ 추가
  textSizeInfo         // ✅ 추가
}) => {
  
  // handleMouseMove - move 모드 수정
  if (dragMode === 'move') {
    const newX = transform.x + dx;
    const newY = transform.y + dy;
    
    // ✅ 박스 중심을 이미지 좌표로 변환
    const boxCenterX = (newX / 100) * imageSize.width;
    const boxCenterY = (newY / 100) * imageSize.height;
    
    // ✅ 간판 영역 계산
    let signboardX, signboardY, signboardWidth, signboardHeight;
    if (selectedArea?.type === 'polygon' && selectedArea.points.length >= 4) {
      const xs = selectedArea.points.map(p => p.x);
      const ys = selectedArea.points.map(p => p.y);
      signboardX = Math.min(...xs);
      signboardY = Math.min(...ys);
      signboardWidth = Math.max(...xs) - signboardX;
      signboardHeight = Math.max(...ys) - signboardY;
    } else if (selectedArea) {
      signboardX = selectedArea.x;
      signboardY = selectedArea.y;
      signboardWidth = selectedArea.width;
      signboardHeight = selectedArea.height;
    }
    
    // ✅ 간판 영역 내에서의 텍스트 중심 위치
    const textCenterX = boxCenterX - signboardX;
    const textCenterY = boxCenterY - signboardY;
    
    // ✅ 텍스트 크기 계산
    let textWidth, textHeight;
    if (textSizeInfo?.text_width && textSizeInfo?.text_height) {
      const scaleX = imageSize.width / textSizeInfo.signboard_width;
      const scaleY = imageSize.height / textSizeInfo.signboard_height;
      textWidth = textSizeInfo.text_width * scaleX;
      textHeight = textSizeInfo.text_height * scaleY;
    } else {
      // 폴백: fontSize 기반 추정
      const sb = originalSignboards.find(s => s.id === selectedId);
      const fontSize = sb?.formData?.fontSize || 100;
      textWidth = signboardWidth * 0.5 * Math.sqrt(fontSize / 100);
      textHeight = signboardHeight * 0.4 * Math.sqrt(fontSize / 100);
    }
    
    // ✅ textPositionX/Y 계산 (0-100%)
    const availableWidth = signboardWidth - textWidth;
    const availableHeight = signboardHeight - textHeight;
    
    const textPositionX = availableWidth > 0 
      ? ((textCenterX - textWidth / 2) / availableWidth) * 100 
      : 50;
    const textPositionY = availableHeight > 0 
      ? ((textCenterY - textHeight / 2) / availableHeight) * 100 
      : 50;
    
    // ✅ 범위 제한 (0-100%)
    const clampedX = Math.max(0, Math.min(100, textPositionX));
    const clampedY = Math.max(0, Math.min(100, textPositionY));
    
    updateTransform(selectedId, {
      x: newX,
      y: newY,
      textPositionX: clampedX,  // ✅ 추가
      textPositionY: clampedY,  // ✅ 추가
    });
  }
}
```

**2. ResultViewer.js**
```javascript
<SignboardTransform
  signboards={...}
  originalSignboards={originalSignboards}
  imageSize={imageSize}
  onTransformChange={setPendingTransforms}
  onApply={handleApplyTransforms}
  selectedArea={selectedArea}        // ✅ 추가
  textSizeInfo={textSizeInfo}         // ✅ 추가
/>
```

**3. App.js**
```javascript
onRegenerateWithTransforms={async (transforms) => {
  // ...
  if (transform.fontSize !== undefined) {
    updatedFormData.fontSize = transform.fontSize;
  }
  if (transform.rotation !== undefined) {
    updatedFormData.rotation = transform.rotation;
  }
  // ✅ 추가
  if (transform.textPositionX !== undefined) {
    updatedFormData.textPositionX = transform.textPositionX;
  }
  if (transform.textPositionY !== undefined) {
    updatedFormData.textPositionY = transform.textPositionY;
  }
  // ...
}}
```

#### 장점
- ✅ 사용자 경험 향상: 파란박스만 조작하면 텍스트 위치도 자동 업데이트
- ✅ 직관적: 하나의 인터페이스로 모든 조정 가능
- ✅ 데이터 일관성: 박스 위치와 텍스트 위치가 항상 동기화

#### 단점
- ⚠️ 구현 복잡도 증가: 좌표 변환 로직 추가 필요
- ⚠️ 테스트 필요: 줌/팬 상태에서의 정확도 검증 필요

---

### 방안 2: 현재 상태 유지 + 개선

**목표**: 두 기능을 분리하되, 각각의 기능을 더 명확하게

#### 수정 사항
- 파란박스: "간판 크기/회전 편집"으로 명확히 표시
- 보라박스: "상호 위치 편집"으로 명확히 표시
- UI 개선: 두 모드의 차이를 더 명확하게 표시

#### 장점
- ✅ 구현 간단: 기존 코드 수정 최소화
- ✅ 기능 분리: 각 기능의 책임이 명확

#### 단점
- ❌ 사용자 혼란: 두 가지 편집 모드가 있어 혼란스러울 수 있음
- ❌ 데이터 불일치: 파란박스와 텍스트 위치가 따로 놀 수 있음

---

## 🎯 권장 사항

### 즉시 구현 권장: 방안 1 (통합 구현)

**이유**:
1. **사용자 경험**: 파란박스를 이동하면 텍스트도 함께 이동하는 것이 직관적
2. **INTEGRATION_SUMMARY.md**: 이미 통합 계획이 문서화되어 있음
3. **기술적 실현 가능**: 필요한 정보(selectedArea, textSizeInfo)는 이미 있음

### 구현 순서
1. ✅ `ResultViewer.js`: `selectedArea`, `textSizeInfo` props 전달
2. ✅ `SignboardTransform.js`: Props 추가 및 `handleMouseMove` 수정
3. ✅ `App.js`: `onRegenerateWithTransforms`에서 `textPositionX/Y` 처리
4. ✅ 테스트: 박스 이동 → 텍스트 위치 변경 확인

---

## 📊 예상 문제점 및 해결책

### 1. 좌표 변환 오차
**문제**: 줌/팬이 적용된 상태에서의 정확도  
**해결**: `imageSize`를 정확히 사용하고, 픽셀 단위로 계산 후 퍼센트로 변환

### 2. 텍스트 크기 추정
**문제**: `textSizeInfo`가 없을 때의 추정 정확도  
**해결**: `textSizeInfo` 우선 사용, 없으면 Canvas로 정확히 계산

### 3. 경계 처리
**문제**: 간판 영역 밖으로 나가는 경우  
**해결**: 0-100% 범위로 제한, 경계에서 멈추도록 처리

---

## ✅ 체크리스트

### 구현 전 확인
- [ ] `selectedArea`가 `ResultViewer`에서 정확히 전달되는지 확인
- [ ] `textSizeInfo`가 API 응답에서 정확히 오는지 확인
- [ ] `imageSize`가 정확한지 확인

### 구현 후 테스트
- [ ] 박스 이동 → 텍스트 위치 변경 확인
- [ ] 박스 크기 조절 → fontSize 변경 확인 (기존 기능)
- [ ] 회전 → 텍스트 회전 확인 (기존 기능)
- [ ] 적용하기 → 재생성 후 위치 유지 확인
- [ ] 다시 간판편집 열기 → 박스 위치 정확도 확인
- [ ] 줌/팬 상태에서의 정확도 확인

---

## 📝 결론

**현재 상태**: 파란박스는 박스 이동/크기/회전만 처리하고, 텍스트 위치는 별도의 보라박스로 처리됨

**문제점**: 두 기능이 분리되어 있어 사용자가 혼란스러울 수 있고, 데이터 동기화가 안 됨

**권장 사항**: 방안 1(통합 구현)을 통해 파란박스 이동 시 텍스트 위치도 자동 업데이트되도록 구현

**다음 단계**: 사용자 확인 후 구현 진행
